// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.6
// source: proto/kanbee.proto

package kbp

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	KanbanService_CreateProject_FullMethodName   = "/kanban.KanbanService/CreateProject"
	KanbanService_UpdateProject_FullMethodName   = "/kanban.KanbanService/UpdateProject"
	KanbanService_GetProjectById_FullMethodName  = "/kanban.KanbanService/GetProjectById"
	KanbanService_ListProjects_FullMethodName    = "/kanban.KanbanService/ListProjects"
	KanbanService_CreateTask_FullMethodName      = "/kanban.KanbanService/CreateTask"
	KanbanService_UpdateTask_FullMethodName      = "/kanban.KanbanService/UpdateTask"
	KanbanService_UpdateTaskState_FullMethodName = "/kanban.KanbanService/UpdateTaskState"
	KanbanService_GetTaskById_FullMethodName     = "/kanban.KanbanService/GetTaskById"
	KanbanService_ListTasks_FullMethodName       = "/kanban.KanbanService/ListTasks"
	KanbanService_CreateUpdate_FullMethodName    = "/kanban.KanbanService/CreateUpdate"
	KanbanService_ListUpdates_FullMethodName     = "/kanban.KanbanService/ListUpdates"
)

// KanbanServiceClient is the client API for KanbanService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// gRPC service definition for Kanban operations
type KanbanServiceClient interface {
	// Project operations
	CreateProject(ctx context.Context, in *CreateProjectRequest, opts ...grpc.CallOption) (*ProjectResponse, error)
	UpdateProject(ctx context.Context, in *UpdateProjectRequest, opts ...grpc.CallOption) (*ProjectResponse, error)
	GetProjectById(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*ProjectResponse, error)
	ListProjects(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListProjectsResponse, error)
	// Task operations
	CreateTask(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*TaskResponse, error)
	UpdateTask(ctx context.Context, in *UpdateTaskRequest, opts ...grpc.CallOption) (*TaskResponse, error)
	UpdateTaskState(ctx context.Context, in *UpdateTaskStateRequest, opts ...grpc.CallOption) (*TaskResponse, error)
	GetTaskById(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*TaskResponse, error)
	ListTasks(ctx context.Context, in *ListTasksRequest, opts ...grpc.CallOption) (*ListTasksResponse, error)
	// Update operations
	CreateUpdate(ctx context.Context, in *CreateUpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error)
	ListUpdates(ctx context.Context, in *ListUpdatesRequest, opts ...grpc.CallOption) (*ListUpdatesResponse, error)
}

type kanbanServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewKanbanServiceClient(cc grpc.ClientConnInterface) KanbanServiceClient {
	return &kanbanServiceClient{cc}
}

func (c *kanbanServiceClient) CreateProject(ctx context.Context, in *CreateProjectRequest, opts ...grpc.CallOption) (*ProjectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectResponse)
	err := c.cc.Invoke(ctx, KanbanService_CreateProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kanbanServiceClient) UpdateProject(ctx context.Context, in *UpdateProjectRequest, opts ...grpc.CallOption) (*ProjectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectResponse)
	err := c.cc.Invoke(ctx, KanbanService_UpdateProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kanbanServiceClient) GetProjectById(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*ProjectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectResponse)
	err := c.cc.Invoke(ctx, KanbanService_GetProjectById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kanbanServiceClient) ListProjects(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListProjectsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProjectsResponse)
	err := c.cc.Invoke(ctx, KanbanService_ListProjects_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kanbanServiceClient) CreateTask(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*TaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskResponse)
	err := c.cc.Invoke(ctx, KanbanService_CreateTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kanbanServiceClient) UpdateTask(ctx context.Context, in *UpdateTaskRequest, opts ...grpc.CallOption) (*TaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskResponse)
	err := c.cc.Invoke(ctx, KanbanService_UpdateTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kanbanServiceClient) UpdateTaskState(ctx context.Context, in *UpdateTaskStateRequest, opts ...grpc.CallOption) (*TaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskResponse)
	err := c.cc.Invoke(ctx, KanbanService_UpdateTaskState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kanbanServiceClient) GetTaskById(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*TaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskResponse)
	err := c.cc.Invoke(ctx, KanbanService_GetTaskById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kanbanServiceClient) ListTasks(ctx context.Context, in *ListTasksRequest, opts ...grpc.CallOption) (*ListTasksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTasksResponse)
	err := c.cc.Invoke(ctx, KanbanService_ListTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kanbanServiceClient) CreateUpdate(ctx context.Context, in *CreateUpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateResponse)
	err := c.cc.Invoke(ctx, KanbanService_CreateUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kanbanServiceClient) ListUpdates(ctx context.Context, in *ListUpdatesRequest, opts ...grpc.CallOption) (*ListUpdatesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUpdatesResponse)
	err := c.cc.Invoke(ctx, KanbanService_ListUpdates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KanbanServiceServer is the server API for KanbanService service.
// All implementations must embed UnimplementedKanbanServiceServer
// for forward compatibility.
//
// gRPC service definition for Kanban operations
type KanbanServiceServer interface {
	// Project operations
	CreateProject(context.Context, *CreateProjectRequest) (*ProjectResponse, error)
	UpdateProject(context.Context, *UpdateProjectRequest) (*ProjectResponse, error)
	GetProjectById(context.Context, *GetByIdRequest) (*ProjectResponse, error)
	ListProjects(context.Context, *Empty) (*ListProjectsResponse, error)
	// Task operations
	CreateTask(context.Context, *CreateTaskRequest) (*TaskResponse, error)
	UpdateTask(context.Context, *UpdateTaskRequest) (*TaskResponse, error)
	UpdateTaskState(context.Context, *UpdateTaskStateRequest) (*TaskResponse, error)
	GetTaskById(context.Context, *GetByIdRequest) (*TaskResponse, error)
	ListTasks(context.Context, *ListTasksRequest) (*ListTasksResponse, error)
	// Update operations
	CreateUpdate(context.Context, *CreateUpdateRequest) (*UpdateResponse, error)
	ListUpdates(context.Context, *ListUpdatesRequest) (*ListUpdatesResponse, error)
	mustEmbedUnimplementedKanbanServiceServer()
}

// UnimplementedKanbanServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKanbanServiceServer struct{}

func (UnimplementedKanbanServiceServer) CreateProject(context.Context, *CreateProjectRequest) (*ProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProject not implemented")
}
func (UnimplementedKanbanServiceServer) UpdateProject(context.Context, *UpdateProjectRequest) (*ProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProject not implemented")
}
func (UnimplementedKanbanServiceServer) GetProjectById(context.Context, *GetByIdRequest) (*ProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectById not implemented")
}
func (UnimplementedKanbanServiceServer) ListProjects(context.Context, *Empty) (*ListProjectsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProjects not implemented")
}
func (UnimplementedKanbanServiceServer) CreateTask(context.Context, *CreateTaskRequest) (*TaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTask not implemented")
}
func (UnimplementedKanbanServiceServer) UpdateTask(context.Context, *UpdateTaskRequest) (*TaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTask not implemented")
}
func (UnimplementedKanbanServiceServer) UpdateTaskState(context.Context, *UpdateTaskStateRequest) (*TaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTaskState not implemented")
}
func (UnimplementedKanbanServiceServer) GetTaskById(context.Context, *GetByIdRequest) (*TaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTaskById not implemented")
}
func (UnimplementedKanbanServiceServer) ListTasks(context.Context, *ListTasksRequest) (*ListTasksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTasks not implemented")
}
func (UnimplementedKanbanServiceServer) CreateUpdate(context.Context, *CreateUpdateRequest) (*UpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUpdate not implemented")
}
func (UnimplementedKanbanServiceServer) ListUpdates(context.Context, *ListUpdatesRequest) (*ListUpdatesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUpdates not implemented")
}
func (UnimplementedKanbanServiceServer) mustEmbedUnimplementedKanbanServiceServer() {}
func (UnimplementedKanbanServiceServer) testEmbeddedByValue()                       {}

// UnsafeKanbanServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KanbanServiceServer will
// result in compilation errors.
type UnsafeKanbanServiceServer interface {
	mustEmbedUnimplementedKanbanServiceServer()
}

func RegisterKanbanServiceServer(s grpc.ServiceRegistrar, srv KanbanServiceServer) {
	// If the following call pancis, it indicates UnimplementedKanbanServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&KanbanService_ServiceDesc, srv)
}

func _KanbanService_CreateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KanbanServiceServer).CreateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KanbanService_CreateProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KanbanServiceServer).CreateProject(ctx, req.(*CreateProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KanbanService_UpdateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KanbanServiceServer).UpdateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KanbanService_UpdateProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KanbanServiceServer).UpdateProject(ctx, req.(*UpdateProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KanbanService_GetProjectById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KanbanServiceServer).GetProjectById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KanbanService_GetProjectById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KanbanServiceServer).GetProjectById(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KanbanService_ListProjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KanbanServiceServer).ListProjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KanbanService_ListProjects_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KanbanServiceServer).ListProjects(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _KanbanService_CreateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KanbanServiceServer).CreateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KanbanService_CreateTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KanbanServiceServer).CreateTask(ctx, req.(*CreateTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KanbanService_UpdateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KanbanServiceServer).UpdateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KanbanService_UpdateTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KanbanServiceServer).UpdateTask(ctx, req.(*UpdateTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KanbanService_UpdateTaskState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTaskStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KanbanServiceServer).UpdateTaskState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KanbanService_UpdateTaskState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KanbanServiceServer).UpdateTaskState(ctx, req.(*UpdateTaskStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KanbanService_GetTaskById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KanbanServiceServer).GetTaskById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KanbanService_GetTaskById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KanbanServiceServer).GetTaskById(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KanbanService_ListTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KanbanServiceServer).ListTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KanbanService_ListTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KanbanServiceServer).ListTasks(ctx, req.(*ListTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KanbanService_CreateUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KanbanServiceServer).CreateUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KanbanService_CreateUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KanbanServiceServer).CreateUpdate(ctx, req.(*CreateUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KanbanService_ListUpdates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUpdatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KanbanServiceServer).ListUpdates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KanbanService_ListUpdates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KanbanServiceServer).ListUpdates(ctx, req.(*ListUpdatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KanbanService_ServiceDesc is the grpc.ServiceDesc for KanbanService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KanbanService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "kanban.KanbanService",
	HandlerType: (*KanbanServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProject",
			Handler:    _KanbanService_CreateProject_Handler,
		},
		{
			MethodName: "UpdateProject",
			Handler:    _KanbanService_UpdateProject_Handler,
		},
		{
			MethodName: "GetProjectById",
			Handler:    _KanbanService_GetProjectById_Handler,
		},
		{
			MethodName: "ListProjects",
			Handler:    _KanbanService_ListProjects_Handler,
		},
		{
			MethodName: "CreateTask",
			Handler:    _KanbanService_CreateTask_Handler,
		},
		{
			MethodName: "UpdateTask",
			Handler:    _KanbanService_UpdateTask_Handler,
		},
		{
			MethodName: "UpdateTaskState",
			Handler:    _KanbanService_UpdateTaskState_Handler,
		},
		{
			MethodName: "GetTaskById",
			Handler:    _KanbanService_GetTaskById_Handler,
		},
		{
			MethodName: "ListTasks",
			Handler:    _KanbanService_ListTasks_Handler,
		},
		{
			MethodName: "CreateUpdate",
			Handler:    _KanbanService_CreateUpdate_Handler,
		},
		{
			MethodName: "ListUpdates",
			Handler:    _KanbanService_ListUpdates_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/kanbee.proto",
}
